# 第四章 复合类型

## 数组

数组的声明 typeName arrayName[arraySize];

* arraySize 必须是整型常数或 const 值，也可以是常量表达式
* 即其中所有的值在编译时都是已知的，arraySize 不能是变量
* 编译器不会检查使用的下标是否有效，但无效的赋值可能引发问题

数组的初始化规则

* 只有在定义数组时才能使用初始化
* 也不能将一个数组赋值给另一个数组
* 可以使用下标分别给数组中的元素赋值
* 初始化数组时，提供的值可以少于数组的元素数目

C++ 11 的数组初始化方法

* 初始化数组时，可以省略等号(=)
* 可不在大括号内包含任何东西，这将把所有元素都设置为零
* 列表初始化禁止缩窄转换

## 字符串

C-风格字符串

* C-风格字符串以空字符结尾，空字符被写作 \0，其 ASCII 码为 0

* 使用引号括起的字符串也可以将字符数组初始化为字符串，这种字符串被称为字符串常量(string constant)或字符串字面值(string literal)

* 用引号括起的字符串隐式地包含结尾的空字符

* 用引号括起的字符串实际上表示的是字符串所在的内存地址

* 标准头文件 cstring 提供了 strlen() 以及很多与字符串相关的其他函数的声明

* strlen() 只计算可见的字符，不把空字符计算在内

* cin 使用空白(空格，制表符和换行符)来确定字符串的结束位置，因此 cin 读取字符数组输入时只读取一个单词

面向行的输入 getline() 和 get()

* getline() 通过回车键输入的换行符来确定输入结尾。该函数有两个参数，第一个是数组名，第二个是要读取的字符数

* get() 不再读取并丢弃换行符，而是将其留在输入队列中

* get() 可以拼接使用

  ```cpp
  cin.get(name, arSize).get();
  ```

* 老式实现没有 getline()，另外 get() 使输入更仔细

* 使用 get() 要注意空行问题，混合输入字符串和数字导致问题

## String 类

要使用 string 类，必须在程序中包含头文件 string

* 可以使用 C-风格字符串来初始化 string 对象
* 可以使用 cin 来将键盘输入存储到 string 对象中
* 可以使用 cout 来显示 string 对象
* 可以使用数组表示法来访问存储在 string 对象中的字符

类设计让程序能够自动处理 string 的大小

* 可以将一个 string 对象赋给另一个 string 对象
* 可以使用运算符 + 将两个 string 对象合并起来
* 可以使用运算符 += 将字符串附加到 string 对象的末尾

两种不同风格的字符串确定字符数的方法

```cpp
int len1 = str1.size();    //size()是string类的一个方法
int len2 = strlen(charr1); //strlen()接受C-风格字符串作为参数
```

## 结构（略）

## 共同体(union)

共同体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种

## 枚举

* 默认情况下，将整数值从0开始按顺序赋值给枚举量
* 对于枚举，只定义了赋值运算符，没有算术运算
* 枚举量是整型，可被提升为 int 类型

## 指针和自由存储空间

指针名表示的是地址，*运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址处存储的值

### 声明和初始化指针

```cpp
int* p_updates;
```

*p_updates 的类型为 int，p_updates是指针(地址)，而\*p_updates是int，不是指针

注意下面的声明将创建一个指针(p1)和一个 int 变量(p2)：

```cpp
int* p1, p2;
```

对每个指针变量名，都需要使用一个*

可以在声明语句中初始化指针，这种情况下被初始化的是指针，而不是它指向的值

指针的危险

* 在 C++ 中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存
* 一定要在对指针应用解除引用运算符(*)之前，将指针初始化为一个确定的适当的地址
* 不能简单的将整数赋值给指针

  ```cpp
  int* pt;
  pt = 0xB8000000; // error: type mismatch
  ```

* 要将数字值作为地址来引用，应通过强制类型转换将数字转换为适当的地址类型

  ```cpp
  int* pt;
  pt = (int *) 0xB8000000; // type now match
  ```

### 使用 new 和 delete

使用 new 来分配内存 typeName* pointer_name = new typeName

* 常规变量声明分配的值都存储在被成为栈(stack)的内存区域中
* 而 new 从被称为堆(heap)或自由存储区(free store)的内存区域分配内存

使用 delete 时，后面要加上指向内存块的指针(这些内存块最初是用 new 分配的)：

```cpp
int* ps = new int;
...
delete ps;
```

这将释放 ps 指向的内存，但不会删除指针 ps 本身

* 一定要配对地使用 new 和 delete，否则会发生内存泄漏(memory leak)
* 只能用 delete 来释放使用 new 分配的内存
* 不要使用 delete 释放同一内存块两次
* 如果使用 new[] 为数组分配内存，则应使用 delete[] 来释放
* 对空指针应用 delete 是安全的
* 将指针变量 +1 后，其增加的值等于指向的类型占用的字节数

### 指针和字符串

* 在 cout 和多数 C++ 表达式中，char 数组名、char指针、以及用引号括起的字符串常量都被解释为字符串第一个字符的地址
* 如果给 cout 提供一个指针，它将打印地址
* 但如果指针的类型为 char* ，则 cout 将显示指向的字符串
* 如果要显示字符串的地址，则必须将这种指针强制转换为另一种指针类型

复制字符串

```cpp
strcpy(ps, temp); copy string to new storage
```

strcpy() 函数接受两个参数：第一个是目标地址，第二个是要复制的字符串的地址

如果目标比要复制的字符串小，函数将字符串中剩余的部分复制到数组后面的内存字节中，这可能会覆盖程序正在使用的其他内存。要避免这种问题，请使用 strncpy()

### 自动存储、静态存储和动态存储

* 自动存储：在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，这意味着他们在所属的函数被调用时自动产生，在该函数结束时消亡。自动变量通常存储在栈中
* 静态存储：静态存储是整个程序执行期间都存在的存储方式。可在函数外面定义它，或者在声明变量时使用关键字 static
* 动态存储：new 和 delete 运算符管理了一个内存池，被称为自由存储空间或堆

## 数组的替代品

### 模板类 vector

模板类 vector 类似于 string 类，也是一种动态数组

* 要使用 vector 对象，必须包含头文件 vector
* vector 包含在名称空间 std 中
* 模板使用不同的语法来指出它存储的类型
* vector 类使用不同的语法来指定元素数

  ```cpp
  #include <vecotr>
  ...
  using namespace std;
  vector<int> vi;
  int n;
  cin >> n;
  vector<double> vd[n];
  ```

### 模板类 array

与数组一样，array 对象的长度也是固定的，也使用栈(静态内存分配)，而不是自由存储区

* 效率与数组相同，但更方便，更安全
* 要使用 array 对象，需要包含头文件 array
* array 对象的创建语法与 vector 稍有不同 array<typeName, n_elem> arr;

  ```cpp
  #include <array>
  ...
  using namespace std;
  array<int, 5> ai;
  array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
  ```

* 与 vector 对象不同的是，n_elem 不能是变量

数组，vector，array：

* 都可使用标准数组表示法来访问各个元素
* array 对象和数组村春在相同的内存区域(栈)中，而 vector 对象存储在另一个区域(自由存储区或堆)中
* 可以将 array 对象赋给另一个 array 对象，而对于数组必须逐个元素复制数据

可以使用 vector 和 array 对象的成员函数 at() 来捕获非法索引

可以使用成员函数 begin() 和 end() 来确定边界值以免无意间超界
